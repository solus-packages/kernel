diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c
index fd4100d..41e2913 100644
--- a/drivers/input/joystick/xpad.c
+++ b/drivers/input/joystick/xpad.c
@@ -84,13 +84,14 @@
 #define DRIVER_AUTHOR "Marko Friedemann <mfr@bmx-chemnitz.de>"
 #define DRIVER_DESC "X-Box pad driver"
 
-#define XPAD_PKT_LEN 32
+#define XPAD_PKT_LEN 64
 
 /* xbox d-pads should map to buttons, as is required for DDR pads
    but we map them to axes when possible to simplify things */
 #define MAP_DPAD_TO_BUTTONS		(1 << 0)
 #define MAP_TRIGGERS_TO_BUTTONS		(1 << 1)
 #define MAP_STICKS_TO_NULL		(1 << 2)
+#define MAP_BACK_PADDLES_SEPARATELY	(1 << 3)
 #define DANCEPAD_MAP_CONFIG	(MAP_DPAD_TO_BUTTONS |			\
 				MAP_TRIGGERS_TO_BUTTONS | MAP_STICKS_TO_NULL)
 
@@ -98,7 +99,8 @@
 #define XTYPE_XBOX360     1
 #define XTYPE_XBOX360W    2
 #define XTYPE_XBOXONE     3
-#define XTYPE_UNKNOWN     4
+#define XTYPE_XBOXONE_ELITE     4
+#define XTYPE_UNKNOWN     5
 
 static bool dpad_to_buttons;
 module_param(dpad_to_buttons, bool, S_IRUGO);
@@ -125,7 +127,8 @@ static const struct xpad_device {
 	{ 0x045e, 0x0289, "Microsoft X-Box pad v2 (US)", 0, XTYPE_XBOX },
 	{ 0x045e, 0x028e, "Microsoft X-Box 360 pad", 0, XTYPE_XBOX360 },
 	{ 0x045e, 0x02d1, "Microsoft X-Box One pad", 0, XTYPE_XBOXONE },
-	{ 0x045e, 0x02dd, "Microsoft X-Box One pad (Covert Forces)", 0, XTYPE_XBOXONE },
+	{ 0x045e, 0x02dd, "Microsoft X-Box One pad", 0, XTYPE_XBOXONE },
+	{ 0x045e, 0x02e3, "Microsoft X-Box One Elite pad", /* MAP_BACK_PADDLES_SEPARATELY */ 0, XTYPE_XBOXONE_ELITE },
 	{ 0x045e, 0x0291, "Xbox 360 Wireless Receiver (XBOX)", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360W },
 	{ 0x045e, 0x0719, "Xbox 360 Wireless Receiver", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360W },
 	{ 0x044f, 0x0f07, "Thrustmaster, Inc. Controller", 0, XTYPE_XBOX },
@@ -169,9 +172,12 @@ static const struct xpad_device {
 	{ 0x0e6f, 0x0006, "Edge wireless Controller", 0, XTYPE_XBOX },
 	{ 0x0e6f, 0x0105, "HSM3 Xbox360 dancepad", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360 },
 	{ 0x0e6f, 0x0113, "Afterglow AX.1 Gamepad for Xbox 360", 0, XTYPE_XBOX360 },
+	{ 0x0e6f, 0x0139, "Afterglow Wired Controller for Xbox One", 0, XTYPE_XBOXONE },
+	{ 0x0e6f, 0x0146, "Rock Candy Wired Controller for Xbox One", 0, XTYPE_XBOXONE },
 	{ 0x0e6f, 0x0201, "Pelican PL-3601 'TSZ' Wired Xbox 360 Controller", 0, XTYPE_XBOX360 },
 	{ 0x0e6f, 0x0213, "Afterglow Gamepad for Xbox 360", 0, XTYPE_XBOX360 },
 	{ 0x0e6f, 0x021f, "Rock Candy Gamepad for Xbox 360", 0, XTYPE_XBOX360 },
+	{ 0x0e6f, 0x0246, "Rock Candy Wired Controller for Xbox One", 0, XTYPE_XBOXONE },
 	{ 0x0e6f, 0x0301, "Logic3 Controller", 0, XTYPE_XBOX360 },
 	{ 0x0e6f, 0x0401, "Logic3 Controller", 0, XTYPE_XBOX360 },
 	{ 0x0e8f, 0x0201, "SmartJoy Frag Xpad/PS2 adaptor", 0, XTYPE_XBOX },
@@ -179,6 +185,7 @@ static const struct xpad_device {
 	{ 0x0f0d, 0x000a, "Hori Co. DOA4 FightStick", 0, XTYPE_XBOX360 },
 	{ 0x0f0d, 0x000d, "Hori Fighting Stick EX2", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },
 	{ 0x0f0d, 0x0016, "Hori Real Arcade Pro.EX", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },
+	{ 0x0f0d, 0x0067, "HORIPAD ONE", 0, XTYPE_XBOXONE },
 	{ 0x0f30, 0x0202, "Joytech Advanced Controller", 0, XTYPE_XBOX },
 	{ 0x0f30, 0x8888, "BigBen XBMiniPad Controller", 0, XTYPE_XBOX },
 	{ 0x102c, 0xff0c, "Joytech Wireless Advanced Controller", 0, XTYPE_XBOX },
@@ -195,6 +202,7 @@ static const struct xpad_device {
 	{ 0x162e, 0xbeef, "Joytech Neo-Se Take2", 0, XTYPE_XBOX360 },
 	{ 0x1689, 0xfd00, "Razer Onza Tournament Edition", 0, XTYPE_XBOX360 },
 	{ 0x1689, 0xfd01, "Razer Onza Classic Edition", 0, XTYPE_XBOX360 },
+	{ 0x24c6, 0x542a, "Xbox ONE spectra", 0, XTYPE_XBOXONE },
 	{ 0x24c6, 0x5d04, "Razer Sabertooth", 0, XTYPE_XBOX360 },
 	{ 0x1bad, 0x0002, "Harmonix Rock Band Guitar", 0, XTYPE_XBOX360 },
 	{ 0x1bad, 0x0003, "Harmonix Rock Band Drumkit", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360 },
@@ -205,9 +213,11 @@ static const struct xpad_device {
 	{ 0x1bad, 0xf900, "Harmonix Xbox 360 Controller", 0, XTYPE_XBOX360 },
 	{ 0x1bad, 0xf901, "Gamestop Xbox 360 Controller", 0, XTYPE_XBOX360 },
 	{ 0x1bad, 0xf903, "Tron Xbox 360 controller", 0, XTYPE_XBOX360 },
-	{ 0x24c6, 0x5000, "Razer Atrox Arcade Stick", MAP_TRIGGERS_TO_BUTTONS, XTYPE_XBOX360 },
+	{ 0x24c6, 0x5000, "Razer Atrox Arcade Stick", 0, XTYPE_XBOX360 },
 	{ 0x24c6, 0x5300, "PowerA MINI PROEX Controller", 0, XTYPE_XBOX360 },
 	{ 0x24c6, 0x5303, "Xbox Airflo wired controller", 0, XTYPE_XBOX360 },
+	{ 0x24c6, 0x541a, "PowerA Xbox One Mini Wired Controller", 0, XTYPE_XBOXONE },
+	{ 0x24c6, 0x543a, "PowerA Xbox One wired controller", 0, XTYPE_XBOXONE },
 	{ 0x24c6, 0x5500, "Hori XBOX 360 EX 2 with Turbo", 0, XTYPE_XBOX360 },
 	{ 0x24c6, 0x5501, "Hori Real Arcade Pro VX-SA", 0, XTYPE_XBOX360 },
 	{ 0x24c6, 0x5506, "Hori SOULCALIBUR V Stick", 0, XTYPE_XBOX360 },
@@ -243,6 +253,7 @@ static const signed short xpad_btn_triggers[] = {
 	-1
 };
 
+
 static const signed short xpad360_btn[] = {  /* buttons for x360 controller */
 	BTN_TL, BTN_TR,		/* Button LB/RB */
 	BTN_MODE,		/* The big X button */
@@ -267,6 +278,13 @@ static const signed short xpad_abs_triggers[] = {
 	-1
 };
 
+/* When not mapped to buttons ABXY */
+static const signed short xpad_one_elite_back_paddles[] = {
+	BTN_BASE, BTN_BASE2,
+	BTN_BASE3, BTN_BASE4,
+	-1
+};
+
 /*
  * Xbox 360 has a vendor-specific class, so we cannot match it with only
  * USB_INTERFACE_INFO (also specifically refused by USB subsystem), so we
@@ -302,13 +320,16 @@ static struct usb_device_id xpad_table[] = {
 	XPAD_XBOX360_VENDOR(0x0738),		/* Mad Catz X-Box 360 controllers */
 	{ USB_DEVICE(0x0738, 0x4540) },		/* Mad Catz Beat Pad */
 	XPAD_XBOX360_VENDOR(0x0e6f),		/* 0x0e6f X-Box 360 controllers */
+	XPAD_XBOXONE_VENDOR(0x0e6f),		/* 0x0e6f X-Box One controllers */
 	XPAD_XBOX360_VENDOR(0x12ab),		/* X-Box 360 dance pads */
 	XPAD_XBOX360_VENDOR(0x1430),		/* RedOctane X-Box 360 controllers */
 	XPAD_XBOX360_VENDOR(0x146b),		/* BigBen Interactive Controllers */
 	XPAD_XBOX360_VENDOR(0x1bad),		/* Harminix Rock Band Guitar and Drums */
 	XPAD_XBOX360_VENDOR(0x0f0d),		/* Hori Controllers */
+	XPAD_XBOXONE_VENDOR(0x0f0d),		/* Hori Controllers */
 	XPAD_XBOX360_VENDOR(0x1689),		/* Razer Onza */
 	XPAD_XBOX360_VENDOR(0x24c6),		/* PowerA Controllers */
+	XPAD_XBOXONE_VENDOR(0x24c6),		/* PowerA Controllers */
 	XPAD_XBOX360_VENDOR(0x1532),		/* Razer Sabertooth */
 	XPAD_XBOX360_VENDOR(0x15e4),		/* Numark X-Box 360 controllers */
 	XPAD_XBOX360_VENDOR(0x162e),		/* Joytech X-Box 360 controllers */
@@ -317,34 +338,64 @@ static struct usb_device_id xpad_table[] = {
 
 MODULE_DEVICE_TABLE(usb, xpad_table);
 
+struct irq_out_data {
+	struct list_head list;
+	unsigned char odata[XPAD_PKT_LEN];
+	u32 odata_length;
+};
+
 struct usb_xpad {
 	struct input_dev *dev;		/* input device interface */
 	struct usb_device *udev;	/* usb device */
 	struct usb_interface *intf;	/* usb interface */
 
 	int pad_present;
+	int input_ready;
 
 	struct urb *irq_in;		/* urb for interrupt in report */
 	unsigned char *idata;		/* input data */
 	dma_addr_t idata_dma;
 
 	struct urb *irq_out;		/* urb for interrupt out report */
+	int irq_out_busy;		/* is urb submitted, odata_lock must be held */
 	unsigned char *odata;		/* output data */
 	dma_addr_t odata_dma;
-	struct mutex odata_mutex;
+	spinlock_t odata_lock;
+	struct list_head odata_list;	/* odata_lock must be held */
+
+	unsigned char odata_serial;     /* serial number for xbox one protocol */
 
 #if defined(CONFIG_JOYSTICK_XPAD_LEDS)
 	struct xpad_led *led;
 #endif
 
+	unsigned long joydev_id;
+
 	char phys[64];			/* physical device path */
 
 	int mapping;			/* map d-pad to buttons or to axes */
 	int xtype;			/* type of xbox device */
-	int pad_nr;			/* the order x360 pads were attached */
 	const char *name;		/* name of the device */
+	struct work_struct work;	/* init/remove device from callback */
 };
 
+static int xpad_send_ff(struct usb_xpad *xpad, int strong, int weak);
+static int xpad_init_input(struct usb_xpad *xpad);
+static void xpad_deinit_input(struct usb_xpad *xpad);
+
+static void xpad_send_led_command(struct usb_xpad *xpad, int command);
+static int xpad_open(struct input_dev *dev);
+static void xpad_close(struct input_dev *dev);
+static void xpad_set_up_abs(struct input_dev *input_dev, signed short abs);
+static int xpad_init_ff(struct usb_xpad *xpad);
+static int xpad_find_joydev(struct device *dev, void *data)
+{
+	if (strstr(dev_name(dev), "js"))
+		return 1;
+
+	return 0;
+}
+
 /*
  *	xpad_process_packet
  *
@@ -436,16 +487,7 @@ static void xpad360_process_packet(struct usb_xpad *xpad,
 		input_report_key(dev, BTN_TRIGGER_HAPPY2, data[2] & 0x08);
 		input_report_key(dev, BTN_TRIGGER_HAPPY3, data[2] & 0x01);
 		input_report_key(dev, BTN_TRIGGER_HAPPY4, data[2] & 0x02);
-	}
-
-	/*
-	 * This should be a simple else block. However historically
-	 * xbox360w has mapped DPAD to buttons while xbox360 did not. This
-	 * made no sense, but now we can not just switch back and have to
-	 * support both behaviors.
-	 */
-	if (!(xpad->mapping & MAP_DPAD_TO_BUTTONS) ||
-	    xpad->xtype == XTYPE_XBOX360W) {
+	} else {
 		input_report_abs(dev, ABS_HAT0X,
 				 !!(data[2] & 0x08) - !!(data[2] & 0x04));
 		input_report_abs(dev, ABS_HAT0Y,
@@ -495,7 +537,21 @@ static void xpad360_process_packet(struct usb_xpad *xpad,
 	input_sync(dev);
 }
 
-static void xpad_identify_controller(struct usb_xpad *xpad);
+static void presence_work_function(struct work_struct *work)
+{
+	struct usb_xpad *xpad = container_of(work, struct usb_xpad, work);
+	int error;
+
+	if (xpad->pad_present) {
+		error = xpad_init_input(xpad);
+		if (error) {
+			/* complain only, not much else we can do here */
+			dev_err(&xpad->intf->dev, "unable to init device\n");
+		}
+	} else {
+		xpad_deinit_input(xpad);
+	}
+}
 
 /*
  * xpad360w_process_packet
@@ -513,22 +569,25 @@ static void xpad_identify_controller(struct usb_xpad *xpad);
  */
 static void xpad360w_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned char *data)
 {
+	int presence;
+
 	/* Presence change */
 	if (data[0] & 0x08) {
-		if (data[1] & 0x80) {
-			xpad->pad_present = 1;
-			/*
-			 * Light up the segment corresponding to
-			 * controller number.
-			 */
-			xpad_identify_controller(xpad);
-		} else
-			xpad->pad_present = 0;
+		presence = (data[1] & 0x80) != 0;
+
+		if (xpad->pad_present != presence) {
+			xpad->pad_present = presence;
+			schedule_work(&xpad->work);
+			return;
+		}
 	}
 
 	/* Valid pad data */
 	if (!(data[1] & 0x1))
 		return;
+	
+	if (!xpad->input_ready)
+		return;
 
 	xpad360_process_packet(xpad, cmd, &data[4]);
 }
@@ -542,15 +601,28 @@ static void xpadone_process_buttons(struct usb_xpad *xpad,
 				struct input_dev *dev,
 				unsigned char *data)
 {
+	int button_idx;
+
 	/* menu/view buttons */
 	input_report_key(dev, BTN_START,  data[4] & 0x04);
 	input_report_key(dev, BTN_SELECT, data[4] & 0x08);
 
 	/* buttons A,B,X,Y */
-	input_report_key(dev, BTN_A,	data[4] & 0x10);
-	input_report_key(dev, BTN_B,	data[4] & 0x20);
-	input_report_key(dev, BTN_X,	data[4] & 0x40);
-	input_report_key(dev, BTN_Y,	data[4] & 0x80);
+	if (xpad->mapping & MAP_BACK_PADDLES_SEPARATELY) {
+		/* Elite controller has buttons in two locations, 4 and 18.
+		 * Location 4 is coupled to the back paddles, 18 is not */
+		button_idx = 18;
+		input_report_key(dev, BTN_BASE,   data[32] & 0x01);
+		input_report_key(dev, BTN_BASE2,  data[32] & 0x02);
+		input_report_key(dev, BTN_BASE3,  data[32] & 0x04);
+		input_report_key(dev, BTN_BASE4,  data[32] & 0x08);
+	} else {
+		button_idx = 4;
+	}
+	input_report_key(dev, BTN_A,	data[button_idx] & 0x10);
+	input_report_key(dev, BTN_B,	data[button_idx] & 0x20);
+	input_report_key(dev, BTN_X,	data[button_idx] & 0x40);
+	input_report_key(dev, BTN_Y,	data[button_idx] & 0x80);
 
 	/* digital pad */
 	if (xpad->mapping & MAP_DPAD_TO_BUTTONS) {
@@ -647,6 +719,7 @@ static void xpad_irq_in(struct urb *urb)
 	case -ECONNRESET:
 	case -ENOENT:
 	case -ESHUTDOWN:
+	case -EPROTO:
 		/* this urb is terminated, clean up */
 		dev_dbg(dev, "%s - urb shutting down with status: %d\n",
 			__func__, status);
@@ -665,6 +738,7 @@ static void xpad_irq_in(struct urb *urb)
 		xpad360w_process_packet(xpad, 0, xpad->idata);
 		break;
 	case XTYPE_XBOXONE:
+	case XTYPE_XBOXONE_ELITE:
 		xpadone_process_packet(xpad, 0, xpad->idata);
 		break;
 	default:
@@ -678,18 +752,45 @@ exit:
 			__func__, retval);
 }
 
+/* odata_lock must be held */
+static void xpad_clear_odata_list(struct usb_xpad *xpad)
+{
+	struct list_head *n, *p;
+
+	list_for_each_safe(p, n, &xpad->odata_list) {
+		struct irq_out_data *out = list_entry(p, struct irq_out_data, list);
+		list_del(&out->list);
+		kfree(out);
+	}
+}
+
 static void xpad_irq_out(struct urb *urb)
 {
 	struct usb_xpad *xpad = urb->context;
 	struct device *dev = &xpad->intf->dev;
 	int retval, status;
+	struct irq_out_data *out;
+	unsigned long flags;
+
+	spin_lock_irqsave(&xpad->odata_lock, flags);
 
 	status = urb->status;
 
 	switch (status) {
 	case 0:
-		/* success */
-		return;
+		/* success, submit next packet from queue, if not empty */
+		if (!list_empty(&xpad->odata_list)) {
+			out = list_first_entry(&xpad->odata_list,
+					       struct irq_out_data,
+					       list);
+			list_del(&out->list);
+			memcpy(xpad->odata, out->odata, out->odata_length);
+			urb->transfer_buffer_length = out->odata_length;
+			kfree(out);
+			goto resubmit;
+		}
+		xpad->irq_out_busy = 0;
+		goto exit;
 
 	case -ECONNRESET:
 	case -ENOENT:
@@ -697,19 +798,23 @@ static void xpad_irq_out(struct urb *urb)
 		/* this urb is terminated, clean up */
 		dev_dbg(dev, "%s - urb shutting down with status: %d\n",
 			__func__, status);
-		return;
+		xpad_clear_odata_list(xpad);
+		xpad->irq_out_busy = 0;
+		goto exit;
 
 	default:
 		dev_dbg(dev, "%s - nonzero urb status received: %d\n",
 			__func__, status);
-		goto exit;
+		goto resubmit;
 	}
 
-exit:
+resubmit:
 	retval = usb_submit_urb(urb, GFP_ATOMIC);
 	if (retval)
 		dev_err(dev, "%s - usb_submit_urb failed with result %d\n",
 			__func__, retval);
+exit:
+	spin_unlock_irqrestore(&xpad->odata_lock, flags);
 }
 
 static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad)
@@ -728,7 +833,8 @@ static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad)
 		goto fail1;
 	}
 
-	mutex_init(&xpad->odata_mutex);
+	INIT_LIST_HEAD(&xpad->odata_list);
+	spin_lock_init(&xpad->odata_lock);
 
 	xpad->irq_out = usb_alloc_urb(0, GFP_KERNEL);
 	if (!xpad->irq_out) {
@@ -737,7 +843,10 @@ static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad)
 	}
 
 	/* Xbox One controller has in/out endpoints swapped. */
-	ep_irq_out_idx = xpad->xtype == XTYPE_XBOXONE ? 0 : 1;
+	if (xpad->xtype == XTYPE_XBOXONE || xpad->xtype == XTYPE_XBOXONE_ELITE)
+		ep_irq_out_idx = 0;
+	else
+		ep_irq_out_idx = 1;
 	ep_irq_out = &intf->cur_altsetting->endpoint[ep_irq_out_idx].desc;
 
 	usb_fill_int_urb(xpad->irq_out, xpad->udev,
@@ -755,8 +864,22 @@ static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad)
 
 static void xpad_stop_output(struct usb_xpad *xpad)
 {
-	if (xpad->xtype != XTYPE_UNKNOWN)
+	unsigned long flags;
+
+	if (xpad->xtype != XTYPE_UNKNOWN) {
 		usb_kill_urb(xpad->irq_out);
+
+		spin_lock_irqsave(&xpad->odata_lock, flags);
+
+		/* Empty odata_list, in case URB was not pending */
+		xpad_clear_odata_list(xpad);
+		xpad->irq_out_busy = 0;
+
+		spin_unlock_irqrestore(&xpad->odata_lock, flags);
+
+		/* Stop rumble */
+		xpad_send_ff(xpad, 0, 0);
+	}
 }
 
 static void xpad_deinit_output(struct usb_xpad *xpad)
@@ -768,109 +891,161 @@ static void xpad_deinit_output(struct usb_xpad *xpad)
 	}
 }
 
-static int xpad_inquiry_pad_presence(struct usb_xpad *xpad)
+/* xpad->odata_lock must be held */
+static unsigned char* xpad_get_irq_out_buffer(struct usb_xpad *xpad)
 {
-	int retval;
-
-	mutex_lock(&xpad->odata_mutex);
-
-	xpad->odata[0] = 0x08;
-	xpad->odata[1] = 0x00;
-	xpad->odata[2] = 0x0F;
-	xpad->odata[3] = 0xC0;
-	xpad->odata[4] = 0x00;
-	xpad->odata[5] = 0x00;
-	xpad->odata[6] = 0x00;
-	xpad->odata[7] = 0x00;
-	xpad->odata[8] = 0x00;
-	xpad->odata[9] = 0x00;
-	xpad->odata[10] = 0x00;
-	xpad->odata[11] = 0x00;
-	xpad->irq_out->transfer_buffer_length = 12;
-
-	retval = usb_submit_urb(xpad->irq_out, GFP_KERNEL);
+	struct irq_out_data *out;
+
+	if (xpad->irq_out_busy) {
+		/* Allocate list item and add to the end of odata_list */
+		out = kzalloc(sizeof(*out), GFP_ATOMIC);
+		if (!out)
+			return NULL;
+		INIT_LIST_HEAD(&out->list);
+		list_add_tail(&out->list, &xpad->odata_list);
+		return out->odata;
+	} else {
+		return xpad->odata;
+	}
+}
 
-	mutex_unlock(&xpad->odata_mutex);
+/* xpad->odata_lock must be held */
+static int xpad_submit_irq_out_buffer(struct usb_xpad *xpad, unsigned char* buf, u32 length)
+{
+	struct irq_out_data *out;
 
-	return retval;
+	if (xpad->irq_out_busy) {
+		/* Get the last entry of the list */
+		out = list_entry(xpad->odata_list.prev, struct irq_out_data, list);
+		if (buf == out->odata) {
+			out->odata_length = length;
+		} else {
+			dev_err(&xpad->intf->dev, "%s - bad odata_list item! %p %p\n",
+				__func__, out, buf);
+			return -EINVAL;
+		}
+	} else {
+		if (buf == xpad->irq_out->transfer_buffer) {
+			xpad->irq_out_busy = 1;
+			xpad->irq_out->transfer_buffer_length = length;
+			return usb_submit_urb(xpad->irq_out, GFP_ATOMIC);
+		} else {
+			dev_err(&xpad->intf->dev, "%s - bad irq_out odata! %p %p\n",
+				__func__, xpad->irq_out->transfer_buffer, buf);
+			return -EINVAL;
+		}
+	}
+	return 0;
 }
 
 #ifdef CONFIG_JOYSTICK_XPAD_FF
-static int xpad_play_effect(struct input_dev *dev, void *data, struct ff_effect *effect)
+static int xpad_send_ff(struct usb_xpad *xpad, int strong, int weak)
 {
-	struct usb_xpad *xpad = input_get_drvdata(dev);
-	__u16 strong;
-	__u16 weak;
+	unsigned char *odata;
+	u32 transfer_length = 0;
+	int error = 0;
+	unsigned long flags;
 
-	if (effect->type != FF_RUMBLE)
-		return 0;
+	/* Check type, fall fast for unsupported types */
+	switch (xpad->xtype) {
+		case XTYPE_XBOX:
+		case XTYPE_XBOX360:
+		case XTYPE_XBOX360W:
+		case XTYPE_XBOXONE:
+		case XTYPE_XBOXONE_ELITE:
+			break;
+		default:
+			return -EINVAL;
+	}
 
-	strong = effect->u.rumble.strong_magnitude;
-	weak = effect->u.rumble.weak_magnitude;
+	spin_lock_irqsave(&xpad->odata_lock, flags);
+	odata = xpad_get_irq_out_buffer(xpad);
+	if (!odata) {
+		spin_unlock_irqrestore(&xpad->odata_lock, flags);
+		return -ENOMEM;
+	}
 
 	switch (xpad->xtype) {
-	case XTYPE_XBOX:
-		xpad->odata[0] = 0x00;
-		xpad->odata[1] = 0x06;
-		xpad->odata[2] = 0x00;
-		xpad->odata[3] = strong / 256;	/* left actuator */
-		xpad->odata[4] = 0x00;
-		xpad->odata[5] = weak / 256;	/* right actuator */
-		xpad->irq_out->transfer_buffer_length = 6;
-		break;
 
-	case XTYPE_XBOX360:
-		xpad->odata[0] = 0x00;
-		xpad->odata[1] = 0x08;
-		xpad->odata[2] = 0x00;
-		xpad->odata[3] = strong / 256;  /* left actuator? */
-		xpad->odata[4] = weak / 256;	/* right actuator? */
-		xpad->odata[5] = 0x00;
-		xpad->odata[6] = 0x00;
-		xpad->odata[7] = 0x00;
-		xpad->irq_out->transfer_buffer_length = 8;
-		break;
+		case XTYPE_XBOX:
+			odata[0] = 0x00;
+			odata[1] = 0x06;
+			odata[2] = 0x00;
+			odata[3] = strong / 256;	/* left actuator */
+			odata[4] = 0x00;
+			odata[5] = weak / 256;	/* right actuator */
 
-	case XTYPE_XBOX360W:
-		xpad->odata[0] = 0x00;
-		xpad->odata[1] = 0x01;
-		xpad->odata[2] = 0x0F;
-		xpad->odata[3] = 0xC0;
-		xpad->odata[4] = 0x00;
-		xpad->odata[5] = strong / 256;
-		xpad->odata[6] = weak / 256;
-		xpad->odata[7] = 0x00;
-		xpad->odata[8] = 0x00;
-		xpad->odata[9] = 0x00;
-		xpad->odata[10] = 0x00;
-		xpad->odata[11] = 0x00;
-		xpad->irq_out->transfer_buffer_length = 12;
-		break;
+			transfer_length = 6;
+			break;
 
-	case XTYPE_XBOXONE:
-		xpad->odata[0] = 0x09; /* activate rumble */
-		xpad->odata[1] = 0x08;
-		xpad->odata[2] = 0x00;
-		xpad->odata[3] = 0x08; /* continuous effect */
-		xpad->odata[4] = 0x00; /* simple rumble mode */
-		xpad->odata[5] = 0x03; /* L and R actuator only */
-		xpad->odata[6] = 0x00; /* TODO: LT actuator */
-		xpad->odata[7] = 0x00; /* TODO: RT actuator */
-		xpad->odata[8] = strong / 256;	/* left actuator */
-		xpad->odata[9] = weak / 256;	/* right actuator */
-		xpad->odata[10] = 0x80;	/* length of pulse */
-		xpad->odata[11] = 0x00;	/* stop period of pulse */
-		xpad->irq_out->transfer_buffer_length = 12;
-		break;
+		case XTYPE_XBOX360:
+			odata[0] = 0x00;
+			odata[1] = 0x08;
+			odata[2] = 0x00;
+			odata[3] = strong / 256;  /* left actuator? */
+			odata[4] = weak / 256;	/* right actuator? */
+			odata[5] = 0x00;
+			odata[6] = 0x00;
+			odata[7] = 0x00;
+
+			transfer_length = 8;
+			break;
 
-	default:
-		dev_dbg(&xpad->dev->dev,
-			"%s - rumble command sent to unsupported xpad type: %d\n",
-			__func__, xpad->xtype);
-		return -EINVAL;
+		case XTYPE_XBOX360W:
+			odata[0] = 0x00;
+			odata[1] = 0x01;
+			odata[2] = 0x0F;
+			odata[3] = 0xC0;
+			odata[4] = 0x00;
+			odata[5] = strong / 256;
+			odata[6] = weak / 256;
+			odata[7] = 0x00;
+			odata[8] = 0x00;
+			odata[9] = 0x00;
+			odata[10] = 0x00;
+			odata[11] = 0x00;
+
+			transfer_length = 12;
+			break;
+
+		case XTYPE_XBOXONE:
+		case XTYPE_XBOXONE_ELITE:
+			odata[0] = 0x09;
+			odata[1] = 0x00;
+			odata[2] = xpad->odata_serial++;
+			odata[3] = 0x09;
+			odata[4] = 0x00;
+			odata[5] = 0x0F;
+			odata[6] = 0x00;
+			odata[7] = 0x00;
+			odata[8] = strong / 512;
+			odata[9] = weak / 512;
+			odata[10] = 0xFF;
+			odata[11] = 0x00;
+			odata[12] = 0x00;
+
+			transfer_length = 13;
+			break;
 	}
 
-	return usb_submit_urb(xpad->irq_out, GFP_ATOMIC);
+	error = xpad_submit_irq_out_buffer(xpad, odata, transfer_length);
+
+	spin_unlock_irqrestore(&xpad->odata_lock, flags);
+	return error;
+}
+
+static int xpad_play_effect(struct input_dev *dev, void *data, struct ff_effect *effect)
+{
+	struct usb_xpad *xpad = input_get_drvdata(dev);
+
+	if (effect->type == FF_RUMBLE) {
+		__u16 strong = effect->u.rumble.strong_magnitude;
+		__u16 weak = effect->u.rumble.weak_magnitude;
+
+		return xpad_send_ff(xpad, strong, weak);
+	}
+
+	return 0;
 }
 
 static int xpad_init_ff(struct usb_xpad *xpad)
@@ -885,13 +1060,11 @@ static int xpad_init_ff(struct usb_xpad *xpad)
 
 #else
 static int xpad_init_ff(struct usb_xpad *xpad) { return 0; }
+static int xpad_send_ff(struct usb_xpad *xpad, int strong, int weak) { return 0; }
 #endif
 
 #if defined(CONFIG_JOYSTICK_XPAD_LEDS)
 #include <linux/leds.h>
-#include <linux/idr.h>
-
-static DEFINE_IDA(xpad_pad_seq);
 
 struct xpad_led {
 	char name[16];
@@ -899,67 +1072,50 @@ struct xpad_led {
 	struct usb_xpad *xpad;
 };
 
-/**
- * set the LEDs on Xbox360 / Wireless Controllers
- * @param command
- *  0: off
- *  1: all blink, then previous setting
- *  2: 1/top-left blink, then on
- *  3: 2/top-right blink, then on
- *  4: 3/bottom-left blink, then on
- *  5: 4/bottom-right blink, then on
- *  6: 1/top-left on
- *  7: 2/top-right on
- *  8: 3/bottom-left on
- *  9: 4/bottom-right on
- * 10: rotate
- * 11: blink, based on previous setting
- * 12: slow blink, based on previous setting
- * 13: rotate with two lights
- * 14: persistent slow all blink
- * 15: blink once, then previous setting
- */
 static void xpad_send_led_command(struct usb_xpad *xpad, int command)
 {
-	command %= 16;
-
-	mutex_lock(&xpad->odata_mutex);
+	unsigned char *odata;
+	unsigned long flags;
+	u32 transfer_length = 0;
 
-	switch (xpad->xtype) {
-	case XTYPE_XBOX360:
-		xpad->odata[0] = 0x01;
-		xpad->odata[1] = 0x03;
-		xpad->odata[2] = command;
-		xpad->irq_out->transfer_buffer_length = 3;
-		break;
-	case XTYPE_XBOX360W:
-		xpad->odata[0] = 0x00;
-		xpad->odata[1] = 0x00;
-		xpad->odata[2] = 0x08;
-		xpad->odata[3] = 0x40 + command;
-		xpad->odata[4] = 0x00;
-		xpad->odata[5] = 0x00;
-		xpad->odata[6] = 0x00;
-		xpad->odata[7] = 0x00;
-		xpad->odata[8] = 0x00;
-		xpad->odata[9] = 0x00;
-		xpad->odata[10] = 0x00;
-		xpad->odata[11] = 0x00;
-		xpad->irq_out->transfer_buffer_length = 12;
-		break;
-	}
+	if (xpad->xtype != XTYPE_XBOX360 && xpad->xtype != XTYPE_XBOX360W)
+		return;
 
-	usb_submit_urb(xpad->irq_out, GFP_KERNEL);
-	mutex_unlock(&xpad->odata_mutex);
-}
+	if (command >= 0 && command < 14) {
+		spin_lock_irqsave(&xpad->odata_lock, flags);
+		odata = xpad_get_irq_out_buffer(xpad);
+
+		if (odata) {
+			switch (xpad->xtype) {
+
+				case XTYPE_XBOX360:
+					odata[0] = 0x01;
+					odata[1] = 0x03;
+					odata[2] = command;
+					transfer_length = 3;
+					break;
+
+				case XTYPE_XBOX360W:
+					odata[0] = 0x00;
+					odata[1] = 0x00;
+					odata[2] = 0x08;
+					odata[3] = 0x40 + (command % 0x0e);
+					odata[4] = 0x00;
+					odata[5] = 0x00;
+					odata[6] = 0x00;
+					odata[7] = 0x00;
+					odata[8] = 0x00;
+					odata[9] = 0x00;
+					odata[10] = 0x00;
+					odata[11] = 0x00;
+					transfer_length = 12;
+					break;
+			}
+			xpad_submit_irq_out_buffer(xpad, odata, transfer_length);
+		}
 
-/*
- * Light up the segment corresponding to the pad number on
- * Xbox 360 Controllers.
- */
-static void xpad_identify_controller(struct usb_xpad *xpad)
-{
-	xpad_send_led_command(xpad, (xpad->pad_nr % 4) + 2);
+		spin_unlock_irqrestore(&xpad->odata_lock, flags);
+	}
 }
 
 static void xpad_led_set(struct led_classdev *led_cdev,
@@ -984,13 +1140,7 @@ static int xpad_led_probe(struct usb_xpad *xpad)
 	if (!led)
 		return -ENOMEM;
 
-	xpad->pad_nr = ida_simple_get(&xpad_pad_seq, 0, 0, GFP_KERNEL);
-	if (xpad->pad_nr < 0) {
-		error = xpad->pad_nr;
-		goto err_free_mem;
-	}
-
-	snprintf(led->name, sizeof(led->name), "xpad%d", xpad->pad_nr);
+	snprintf(led->name, sizeof(led->name), "xpad%lu", xpad->joydev_id);
 	led->xpad = xpad;
 
 	led_cdev = &led->led_cdev;
@@ -998,26 +1148,13 @@ static int xpad_led_probe(struct usb_xpad *xpad)
 	led_cdev->brightness_set = xpad_led_set;
 
 	error = led_classdev_register(&xpad->udev->dev, led_cdev);
-	if (error)
-		goto err_free_id;
-
-	if (xpad->xtype == XTYPE_XBOX360) {
-		/*
-		 * Light up the segment corresponding to controller
-		 * number on wired devices. On wireless we'll do that
-		 * when they respond to "presence" packet.
-		 */
-		xpad_identify_controller(xpad);
+	if (error) {
+		kfree(led);
+		xpad->led = NULL;
+		return error;
 	}
 
 	return 0;
-
-err_free_id:
-	ida_simple_remove(&xpad_pad_seq, xpad->pad_nr);
-err_free_mem:
-	kfree(led);
-	xpad->led = NULL;
-	return error;
 }
 
 static void xpad_led_disconnect(struct usb_xpad *xpad)
@@ -1026,16 +1163,61 @@ static void xpad_led_disconnect(struct usb_xpad *xpad)
 
 	if (xpad_led) {
 		led_classdev_unregister(&xpad_led->led_cdev);
-		ida_simple_remove(&xpad_pad_seq, xpad->pad_nr);
 		kfree(xpad_led);
 	}
 }
 #else
 static int xpad_led_probe(struct usb_xpad *xpad) { return 0; }
 static void xpad_led_disconnect(struct usb_xpad *xpad) { }
-static void xpad_identify_controller(struct usb_xpad *xpad) { }
 #endif
 
+static int xpad_send_irq_out(struct usb_xpad *xpad, const uint8_t *data, size_t datalen)
+{
+	int ret;
+	unsigned char *odata;
+	unsigned long flags;
+
+	spin_lock_irqsave(&xpad->odata_lock, flags);
+	odata = xpad_get_irq_out_buffer(xpad);
+	if (!odata) {
+		spin_unlock_irqrestore(&xpad->odata_lock, flags);
+		return -ENOMEM;
+	}
+	memcpy(odata, data, datalen);
+	ret = xpad_submit_irq_out_buffer(xpad, odata, datalen);
+	spin_unlock_irqrestore(&xpad->odata_lock, flags);
+	return ret;
+}
+
+static int xpad_init_xbox_one_controller(struct usb_xpad *xpad)
+{
+	int ret = 0;
+
+	if (xpad->xtype == XTYPE_XBOXONE) {
+		static const uint8_t xbox_one_init_1[] = { 0x05, 0x20, 0x00, 0x01, 0x00 };
+		ret = xpad_send_irq_out(xpad, xbox_one_init_1, sizeof(xbox_one_init_1));
+		xpad->odata_serial = 1;
+	} else if (xpad->xtype == XTYPE_XBOXONE_ELITE) {
+		static const uint8_t xbox_one_elite_init_1[] = {
+			0x05, 0x20, 0x00, 0x09, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x53
+		};
+		static const uint8_t xbox_one_elite_init_2[] = {
+			0x05, 0x20, 0x01, 0x01, 0x00
+		};
+		static const uint8_t xbox_one_elite_init_3[] = {
+			0x0A, 0x20, 0x02, 0x03, 0x00, 0x01, 0x14
+		};
+		ret = xpad_send_irq_out(xpad, xbox_one_elite_init_1, sizeof(xbox_one_elite_init_1));
+		if (ret) return ret;
+		ret = xpad_send_irq_out(xpad, xbox_one_elite_init_2, sizeof(xbox_one_elite_init_2));
+		if (ret) return ret;
+		ret = xpad_send_irq_out(xpad, xbox_one_elite_init_3, sizeof(xbox_one_elite_init_3));
+		if (ret) return ret;
+		xpad->odata_serial = 3;
+	}
+	return ret;
+}
+
 static int xpad_open(struct input_dev *dev)
 {
 	struct usb_xpad *xpad = input_get_drvdata(dev);
@@ -1048,12 +1230,8 @@ static int xpad_open(struct input_dev *dev)
 	if (usb_submit_urb(xpad->irq_in, GFP_KERNEL))
 		return -EIO;
 
-	if (xpad->xtype == XTYPE_XBOXONE) {
-		/* Xbox one controller needs to be initialized. */
-		xpad->odata[0] = 0x05;
-		xpad->odata[1] = 0x20;
-		xpad->irq_out->transfer_buffer_length = 2;
-		return usb_submit_urb(xpad->irq_out, GFP_KERNEL);
+	if (xpad->xtype == XTYPE_XBOXONE || xpad->xtype == XTYPE_XBOXONE_ELITE) {
+		return xpad_init_xbox_one_controller(xpad);
 	}
 
 	return 0;
@@ -1083,7 +1261,7 @@ static void xpad_set_up_abs(struct input_dev *input_dev, signed short abs)
 		break;
 	case ABS_Z:
 	case ABS_RZ:	/* the triggers (if mapped to axes) */
-		if (xpad->xtype == XTYPE_XBOXONE)
+		if (xpad->xtype == XTYPE_XBOXONE || xpad->xtype == XTYPE_XBOXONE_ELITE)
 			input_set_abs_params(input_dev, abs, 0, 1023, 0, 0);
 		else
 			input_set_abs_params(input_dev, abs, 0, 255, 0, 0);
@@ -1095,12 +1273,6 @@ static void xpad_set_up_abs(struct input_dev *input_dev, signed short abs)
 	}
 }
 
-static void xpad_deinit_input(struct usb_xpad *xpad)
-{
-	xpad_led_disconnect(xpad);
-	input_unregister_device(xpad->dev);
-}
-
 static int xpad_init_input(struct usb_xpad *xpad)
 {
 	struct input_dev *input_dev;
@@ -1121,10 +1293,10 @@ static int xpad_init_input(struct usb_xpad *xpad)
 	input_dev->open = xpad_open;
 	input_dev->close = xpad_close;
 
-	__set_bit(EV_KEY, input_dev->evbit);
+	input_dev->evbit[0] = BIT_MASK(EV_KEY);
 
 	if (!(xpad->mapping & MAP_STICKS_TO_NULL)) {
-		__set_bit(EV_ABS, input_dev->evbit);
+		input_dev->evbit[0] |= BIT_MASK(EV_ABS);
 		/* set up axes */
 		for (i = 0; xpad_abs[i] >= 0; i++)
 			xpad_set_up_abs(input_dev, xpad_abs[i]);
@@ -1136,7 +1308,7 @@ static int xpad_init_input(struct usb_xpad *xpad)
 
 	/* set up model-specific ones */
 	if (xpad->xtype == XTYPE_XBOX360 || xpad->xtype == XTYPE_XBOX360W ||
-	    xpad->xtype == XTYPE_XBOXONE) {
+	    xpad->xtype == XTYPE_XBOXONE || xpad->xtype == XTYPE_XBOXONE_ELITE) {
 		for (i = 0; xpad360_btn[i] >= 0; i++)
 			__set_bit(xpad360_btn[i], input_dev->keybit);
 	} else {
@@ -1147,16 +1319,7 @@ static int xpad_init_input(struct usb_xpad *xpad)
 	if (xpad->mapping & MAP_DPAD_TO_BUTTONS) {
 		for (i = 0; xpad_btn_pad[i] >= 0; i++)
 			__set_bit(xpad_btn_pad[i], input_dev->keybit);
-	}
-
-	/*
-	 * This should be a simple else block. However historically
-	 * xbox360w has mapped DPAD to buttons while xbox360 did not. This
-	 * made no sense, but now we can not just switch back and have to
-	 * support both behaviors.
-	 */
-	if (!(xpad->mapping & MAP_DPAD_TO_BUTTONS) ||
-	    xpad->xtype == XTYPE_XBOX360W) {
+	} else {
 		for (i = 0; xpad_abs_pad[i] >= 0; i++)
 			xpad_set_up_abs(input_dev, xpad_abs_pad[i]);
 	}
@@ -1169,25 +1332,46 @@ static int xpad_init_input(struct usb_xpad *xpad)
 			xpad_set_up_abs(input_dev, xpad_abs_triggers[i]);
 	}
 
-	error = xpad_init_ff(xpad);
-	if (error)
-		goto err_free_input;
+	if (xpad->mapping & MAP_BACK_PADDLES_SEPARATELY) {
+		for (i = 0; xpad_one_elite_back_paddles[i] >= 0; i++)
+			__set_bit(xpad_one_elite_back_paddles[i], input_dev->keybit);
+	}
 
-	error = xpad_led_probe(xpad);
+	error = xpad_init_ff(xpad);
 	if (error)
-		goto err_destroy_ff;
+		goto fail_init_ff;
 
 	error = input_register_device(xpad->dev);
-	if (error)
-		goto err_disconnect_led;
+	if (error == 0)
+	{
+		struct device* joydev_dev = device_find_child(&xpad->dev->dev, NULL, xpad_find_joydev);
+
+		if (joydev_dev) {
+			xpad->joydev_id = MINOR(joydev_dev->devt);
+		}
+	}
+	else
+	{
+		goto fail_input_register;
+	}
+	
+	xpad->input_ready = 1;
 
+	error = xpad_led_probe(xpad);
+	if (error)
+		goto fail_init_led;
+	
+	xpad_send_led_command(xpad, (xpad->joydev_id % 4) + 2);
+	
 	return 0;
 
-err_disconnect_led:
-	xpad_led_disconnect(xpad);
-err_destroy_ff:
+fail_init_led:
+	xpad_deinit_input(xpad);
+
+fail_input_register:
 	input_ff_destroy(input_dev);
-err_free_input:
+
+fail_init_ff:
 	input_free_device(input_dev);
 	return error;
 }
@@ -1198,7 +1382,10 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
 	struct usb_xpad *xpad;
 	struct usb_endpoint_descriptor *ep_irq_in;
 	int ep_irq_in_idx;
-	int i, error;
+	int i, error = 0;
+	unsigned long flags;
+	unsigned char *odata;
+	int bInterval;
 
 	for (i = 0; xpad_device[i].idVendor; i++) {
 		if ((le16_to_cpu(udev->descriptor.idVendor) == xpad_device[i].idVendor) &&
@@ -1206,7 +1393,7 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
 			break;
 	}
 
-	if (xpad_device[i].xtype == XTYPE_XBOXONE &&
+	if ((xpad_device[i].xtype == XTYPE_XBOXONE || xpad_device[i].xtype == XTYPE_XBOXONE_ELITE) &&
 	    intf->cur_altsetting->desc.bInterfaceNumber != 0) {
 		/*
 		 * The Xbox One controller lists three interfaces all with the
@@ -1217,8 +1404,10 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
 	}
 
 	xpad = kzalloc(sizeof(struct usb_xpad), GFP_KERNEL);
-	if (!xpad)
-		return -ENOMEM;
+	if (!xpad) {
+		error = -ENOMEM;
+		goto fail1;
+	}
 
 	usb_make_path(udev, xpad->phys, sizeof(xpad->phys));
 	strlcat(xpad->phys, "/input0", sizeof(xpad->phys));
@@ -1227,13 +1416,13 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
 					 GFP_KERNEL, &xpad->idata_dma);
 	if (!xpad->idata) {
 		error = -ENOMEM;
-		goto err_free_mem;
+		goto fail1;
 	}
 
 	xpad->irq_in = usb_alloc_urb(0, GFP_KERNEL);
 	if (!xpad->irq_in) {
 		error = -ENOMEM;
-		goto err_free_idata;
+		goto fail2;
 	}
 
 	xpad->udev = udev;
@@ -1241,6 +1430,7 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
 	xpad->mapping = xpad_device[i].mapping;
 	xpad->xtype = xpad_device[i].xtype;
 	xpad->name = xpad_device[i].name;
+	INIT_WORK(&xpad->work, presence_work_function);
 
 	if (xpad->xtype == XTYPE_UNKNOWN) {
 		if (intf->cur_altsetting->desc.bInterfaceClass == USB_CLASS_VENDOR_SPEC) {
@@ -1248,9 +1438,8 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
 				xpad->xtype = XTYPE_XBOX360W;
 			else
 				xpad->xtype = XTYPE_XBOX360;
-		} else {
+		} else
 			xpad->xtype = XTYPE_XBOX;
-		}
 
 		if (dpad_to_buttons)
 			xpad->mapping |= MAP_DPAD_TO_BUTTONS;
@@ -1262,25 +1451,28 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
 
 	error = xpad_init_output(intf, xpad);
 	if (error)
-		goto err_free_in_urb;
+		goto fail3;
 
 	/* Xbox One controller has in/out endpoints swapped. */
-	ep_irq_in_idx = xpad->xtype == XTYPE_XBOXONE ? 1 : 0;
+	if (xpad->xtype == XTYPE_XBOXONE || xpad->xtype == XTYPE_XBOXONE_ELITE)
+		ep_irq_in_idx = 1;
+	else
+		ep_irq_in_idx = 0;
 	ep_irq_in = &intf->cur_altsetting->endpoint[ep_irq_in_idx].desc;
 
+	bInterval = ep_irq_in->bInterval;
+	if (xpad->xtype == XTYPE_XBOX360W)
+		bInterval = 4;
+
 	usb_fill_int_urb(xpad->irq_in, udev,
 			 usb_rcvintpipe(udev, ep_irq_in->bEndpointAddress),
 			 xpad->idata, XPAD_PKT_LEN, xpad_irq_in,
-			 xpad, ep_irq_in->bInterval);
+			 xpad, bInterval);
 	xpad->irq_in->transfer_dma = xpad->idata_dma;
 	xpad->irq_in->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
 	usb_set_intfdata(intf, xpad);
 
-	error = xpad_init_input(xpad);
-	if (error)
-		goto err_deinit_output;
-
 	if (xpad->xtype == XTYPE_XBOX360W) {
 		/*
 		 * Submit the int URB immediately rather than waiting for open
@@ -1291,43 +1483,74 @@ static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id
 		 */
 		xpad->irq_in->dev = xpad->udev;
 		error = usb_submit_urb(xpad->irq_in, GFP_KERNEL);
-		if (error)
-			goto err_deinit_input;
-
+		
+		if (error) {
+			usb_kill_urb(xpad->irq_in);
+			goto fail4;
+		}
+		
+		spin_lock_irqsave(&xpad->odata_lock, flags);
 		/*
-		 * Send presence packet.
+		 * send presence packet
 		 * This will force the controller to resend connection packets.
 		 * This is useful in the case we activate the module after the
 		 * adapter has been plugged in, as it won't automatically
 		 * send us info about the controllers.
 		 */
-		error = xpad_inquiry_pad_presence(xpad);
+		odata = xpad_get_irq_out_buffer(xpad);
+		if (!odata) {
+			spin_unlock_irqrestore(&xpad->odata_lock, flags);
+			error = -ENOMEM;
+			goto fail4;
+		}
+		odata[0] = 0x08;
+		odata[1] = 0x00;
+		odata[2] = 0x0F;
+		odata[3] = 0xC0;
+		odata[4] = 0x00;
+		odata[5] = 0x00;
+		odata[6] = 0x00;
+		odata[7] = 0x00;
+		odata[8] = 0x00;
+		odata[9] = 0x00;
+		odata[10] = 0x00;
+		odata[11] = 0x00;
+		error = xpad_submit_irq_out_buffer(xpad, odata, 12);
+		spin_unlock_irqrestore(&xpad->odata_lock, flags);
 		if (error)
-			goto err_kill_in_urb;
+			goto fail4;
+	} else {
+		xpad->pad_present = 1;
+		error = xpad_init_input(xpad);
+		if (error)
+			goto fail4;
 	}
+
 	return 0;
 
-err_kill_in_urb:
-	usb_kill_urb(xpad->irq_in);
-err_deinit_input:
-	xpad_deinit_input(xpad);
-err_deinit_output:
-	xpad_deinit_output(xpad);
-err_free_in_urb:
-	usb_free_urb(xpad->irq_in);
-err_free_idata:
-	usb_free_coherent(udev, XPAD_PKT_LEN, xpad->idata, xpad->idata_dma);
-err_free_mem:
-	kfree(xpad);
+ fail4:	xpad_deinit_output(xpad);
+ fail3:	usb_free_urb(xpad->irq_in);
+ fail2:	usb_free_coherent(udev, XPAD_PKT_LEN, xpad->idata, xpad->idata_dma);
+ fail1:	kfree(xpad);
 	return error;
 
 }
 
+static void xpad_deinit_input(struct usb_xpad *xpad)
+{
+	xpad_led_disconnect(xpad);
+	input_unregister_device(xpad->dev);
+
+	if (xpad->xtype != XTYPE_XBOX360 && xpad->xtype != XTYPE_XBOX360W)
+		return;
+}
+
 static void xpad_disconnect(struct usb_interface *intf)
 {
 	struct usb_xpad *xpad = usb_get_intfdata (intf);
 
-	xpad_deinit_input(xpad);
+	if (xpad->pad_present)
+		xpad_deinit_input(xpad);
 	xpad_deinit_output(xpad);
 
 	if (xpad->xtype == XTYPE_XBOX360W) {
@@ -1338,6 +1561,8 @@ static void xpad_disconnect(struct usb_interface *intf)
 	usb_free_coherent(xpad->udev, XPAD_PKT_LEN,
 			xpad->idata, xpad->idata_dma);
 
+	cancel_work_sync(&xpad->work);
+
 	kfree(xpad);
 
 	usb_set_intfdata(intf, NULL);
